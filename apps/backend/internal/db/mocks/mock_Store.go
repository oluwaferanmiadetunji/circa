// Code generated by mockery v2.53.5. DO NOT EDIT.

package db

import (
	context "context"

	mock "github.com/stretchr/testify/mock"

	pgtype "github.com/jackc/pgx/v5/pgtype"

	sqlc "circa/internal/db/sqlc/generated"

	uuid "github.com/google/uuid"
)

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// CreateJob provides a mock function with given fields: ctx, arg
func (_m *MockStore) CreateJob(ctx context.Context, arg sqlc.CreateJobParams) (sqlc.Job, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateJob")
	}

	var r0 sqlc.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.CreateJobParams) (sqlc.Job, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.CreateJobParams) sqlc.Job); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(sqlc.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, sqlc.CreateJobParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateJob'
type MockStore_CreateJob_Call struct {
	*mock.Call
}

// CreateJob is a helper method to define mock.On call
//   - ctx context.Context
//   - arg sqlc.CreateJobParams
func (_e *MockStore_Expecter) CreateJob(ctx interface{}, arg interface{}) *MockStore_CreateJob_Call {
	return &MockStore_CreateJob_Call{Call: _e.mock.On("CreateJob", ctx, arg)}
}

func (_c *MockStore_CreateJob_Call) Run(run func(ctx context.Context, arg sqlc.CreateJobParams)) *MockStore_CreateJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(sqlc.CreateJobParams))
	})
	return _c
}

func (_c *MockStore_CreateJob_Call) Return(_a0 sqlc.Job, _a1 error) *MockStore_CreateJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateJob_Call) RunAndReturn(run func(context.Context, sqlc.CreateJobParams) (sqlc.Job, error)) *MockStore_CreateJob_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMagicLink provides a mock function with given fields: ctx, arg
func (_m *MockStore) CreateMagicLink(ctx context.Context, arg sqlc.CreateMagicLinkParams) (sqlc.MagicLink, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreateMagicLink")
	}

	var r0 sqlc.MagicLink
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.CreateMagicLinkParams) (sqlc.MagicLink, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.CreateMagicLinkParams) sqlc.MagicLink); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(sqlc.MagicLink)
	}

	if rf, ok := ret.Get(1).(func(context.Context, sqlc.CreateMagicLinkParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateMagicLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMagicLink'
type MockStore_CreateMagicLink_Call struct {
	*mock.Call
}

// CreateMagicLink is a helper method to define mock.On call
//   - ctx context.Context
//   - arg sqlc.CreateMagicLinkParams
func (_e *MockStore_Expecter) CreateMagicLink(ctx interface{}, arg interface{}) *MockStore_CreateMagicLink_Call {
	return &MockStore_CreateMagicLink_Call{Call: _e.mock.On("CreateMagicLink", ctx, arg)}
}

func (_c *MockStore_CreateMagicLink_Call) Run(run func(ctx context.Context, arg sqlc.CreateMagicLinkParams)) *MockStore_CreateMagicLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(sqlc.CreateMagicLinkParams))
	})
	return _c
}

func (_c *MockStore_CreateMagicLink_Call) Return(_a0 sqlc.MagicLink, _a1 error) *MockStore_CreateMagicLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateMagicLink_Call) RunAndReturn(run func(context.Context, sqlc.CreateMagicLinkParams) (sqlc.MagicLink, error)) *MockStore_CreateMagicLink_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePendingSignup provides a mock function with given fields: ctx, arg
func (_m *MockStore) CreatePendingSignup(ctx context.Context, arg sqlc.CreatePendingSignupParams) (sqlc.PendingSignup, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for CreatePendingSignup")
	}

	var r0 sqlc.PendingSignup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.CreatePendingSignupParams) (sqlc.PendingSignup, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.CreatePendingSignupParams) sqlc.PendingSignup); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(sqlc.PendingSignup)
	}

	if rf, ok := ret.Get(1).(func(context.Context, sqlc.CreatePendingSignupParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreatePendingSignup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePendingSignup'
type MockStore_CreatePendingSignup_Call struct {
	*mock.Call
}

// CreatePendingSignup is a helper method to define mock.On call
//   - ctx context.Context
//   - arg sqlc.CreatePendingSignupParams
func (_e *MockStore_Expecter) CreatePendingSignup(ctx interface{}, arg interface{}) *MockStore_CreatePendingSignup_Call {
	return &MockStore_CreatePendingSignup_Call{Call: _e.mock.On("CreatePendingSignup", ctx, arg)}
}

func (_c *MockStore_CreatePendingSignup_Call) Run(run func(ctx context.Context, arg sqlc.CreatePendingSignupParams)) *MockStore_CreatePendingSignup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(sqlc.CreatePendingSignupParams))
	})
	return _c
}

func (_c *MockStore_CreatePendingSignup_Call) Return(_a0 sqlc.PendingSignup, _a1 error) *MockStore_CreatePendingSignup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreatePendingSignup_Call) RunAndReturn(run func(context.Context, sqlc.CreatePendingSignupParams) (sqlc.PendingSignup, error)) *MockStore_CreatePendingSignup_Call {
	_c.Call.Return(run)
	return _c
}

// GetJobByID provides a mock function with given fields: ctx, id
func (_m *MockStore) GetJobByID(ctx context.Context, id uuid.UUID) (sqlc.Job, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetJobByID")
	}

	var r0 sqlc.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (sqlc.Job, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) sqlc.Job); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(sqlc.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetJobByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJobByID'
type MockStore_GetJobByID_Call struct {
	*mock.Call
}

// GetJobByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) GetJobByID(ctx interface{}, id interface{}) *MockStore_GetJobByID_Call {
	return &MockStore_GetJobByID_Call{Call: _e.mock.On("GetJobByID", ctx, id)}
}

func (_c *MockStore_GetJobByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_GetJobByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetJobByID_Call) Return(_a0 sqlc.Job, _a1 error) *MockStore_GetJobByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetJobByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (sqlc.Job, error)) *MockStore_GetJobByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMagicLinkByPendingSignupID provides a mock function with given fields: ctx, pendingSignupID
func (_m *MockStore) GetMagicLinkByPendingSignupID(ctx context.Context, pendingSignupID uuid.UUID) (sqlc.MagicLink, error) {
	ret := _m.Called(ctx, pendingSignupID)

	if len(ret) == 0 {
		panic("no return value specified for GetMagicLinkByPendingSignupID")
	}

	var r0 sqlc.MagicLink
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (sqlc.MagicLink, error)); ok {
		return rf(ctx, pendingSignupID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) sqlc.MagicLink); ok {
		r0 = rf(ctx, pendingSignupID)
	} else {
		r0 = ret.Get(0).(sqlc.MagicLink)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, pendingSignupID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetMagicLinkByPendingSignupID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMagicLinkByPendingSignupID'
type MockStore_GetMagicLinkByPendingSignupID_Call struct {
	*mock.Call
}

// GetMagicLinkByPendingSignupID is a helper method to define mock.On call
//   - ctx context.Context
//   - pendingSignupID uuid.UUID
func (_e *MockStore_Expecter) GetMagicLinkByPendingSignupID(ctx interface{}, pendingSignupID interface{}) *MockStore_GetMagicLinkByPendingSignupID_Call {
	return &MockStore_GetMagicLinkByPendingSignupID_Call{Call: _e.mock.On("GetMagicLinkByPendingSignupID", ctx, pendingSignupID)}
}

func (_c *MockStore_GetMagicLinkByPendingSignupID_Call) Run(run func(ctx context.Context, pendingSignupID uuid.UUID)) *MockStore_GetMagicLinkByPendingSignupID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetMagicLinkByPendingSignupID_Call) Return(_a0 sqlc.MagicLink, _a1 error) *MockStore_GetMagicLinkByPendingSignupID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetMagicLinkByPendingSignupID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (sqlc.MagicLink, error)) *MockStore_GetMagicLinkByPendingSignupID_Call {
	_c.Call.Return(run)
	return _c
}

// GetMagicLinkByTokenHash provides a mock function with given fields: ctx, tokenHash
func (_m *MockStore) GetMagicLinkByTokenHash(ctx context.Context, tokenHash string) (sqlc.MagicLink, error) {
	ret := _m.Called(ctx, tokenHash)

	if len(ret) == 0 {
		panic("no return value specified for GetMagicLinkByTokenHash")
	}

	var r0 sqlc.MagicLink
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (sqlc.MagicLink, error)); ok {
		return rf(ctx, tokenHash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) sqlc.MagicLink); ok {
		r0 = rf(ctx, tokenHash)
	} else {
		r0 = ret.Get(0).(sqlc.MagicLink)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, tokenHash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetMagicLinkByTokenHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMagicLinkByTokenHash'
type MockStore_GetMagicLinkByTokenHash_Call struct {
	*mock.Call
}

// GetMagicLinkByTokenHash is a helper method to define mock.On call
//   - ctx context.Context
//   - tokenHash string
func (_e *MockStore_Expecter) GetMagicLinkByTokenHash(ctx interface{}, tokenHash interface{}) *MockStore_GetMagicLinkByTokenHash_Call {
	return &MockStore_GetMagicLinkByTokenHash_Call{Call: _e.mock.On("GetMagicLinkByTokenHash", ctx, tokenHash)}
}

func (_c *MockStore_GetMagicLinkByTokenHash_Call) Run(run func(ctx context.Context, tokenHash string)) *MockStore_GetMagicLinkByTokenHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockStore_GetMagicLinkByTokenHash_Call) Return(_a0 sqlc.MagicLink, _a1 error) *MockStore_GetMagicLinkByTokenHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetMagicLinkByTokenHash_Call) RunAndReturn(run func(context.Context, string) (sqlc.MagicLink, error)) *MockStore_GetMagicLinkByTokenHash_Call {
	_c.Call.Return(run)
	return _c
}

// GetNextPendingJob provides a mock function with given fields: ctx
func (_m *MockStore) GetNextPendingJob(ctx context.Context) (sqlc.Job, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetNextPendingJob")
	}

	var r0 sqlc.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (sqlc.Job, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) sqlc.Job); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(sqlc.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetNextPendingJob_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNextPendingJob'
type MockStore_GetNextPendingJob_Call struct {
	*mock.Call
}

// GetNextPendingJob is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockStore_Expecter) GetNextPendingJob(ctx interface{}) *MockStore_GetNextPendingJob_Call {
	return &MockStore_GetNextPendingJob_Call{Call: _e.mock.On("GetNextPendingJob", ctx)}
}

func (_c *MockStore_GetNextPendingJob_Call) Run(run func(ctx context.Context)) *MockStore_GetNextPendingJob_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockStore_GetNextPendingJob_Call) Return(_a0 sqlc.Job, _a1 error) *MockStore_GetNextPendingJob_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetNextPendingJob_Call) RunAndReturn(run func(context.Context) (sqlc.Job, error)) *MockStore_GetNextPendingJob_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingSignupByEmail provides a mock function with given fields: ctx, email
func (_m *MockStore) GetPendingSignupByEmail(ctx context.Context, email pgtype.Text) (sqlc.PendingSignup, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingSignupByEmail")
	}

	var r0 sqlc.PendingSignup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Text) (sqlc.PendingSignup, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Text) sqlc.PendingSignup); ok {
		r0 = rf(ctx, email)
	} else {
		r0 = ret.Get(0).(sqlc.PendingSignup)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgtype.Text) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetPendingSignupByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingSignupByEmail'
type MockStore_GetPendingSignupByEmail_Call struct {
	*mock.Call
}

// GetPendingSignupByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email pgtype.Text
func (_e *MockStore_Expecter) GetPendingSignupByEmail(ctx interface{}, email interface{}) *MockStore_GetPendingSignupByEmail_Call {
	return &MockStore_GetPendingSignupByEmail_Call{Call: _e.mock.On("GetPendingSignupByEmail", ctx, email)}
}

func (_c *MockStore_GetPendingSignupByEmail_Call) Run(run func(ctx context.Context, email pgtype.Text)) *MockStore_GetPendingSignupByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgtype.Text))
	})
	return _c
}

func (_c *MockStore_GetPendingSignupByEmail_Call) Return(_a0 sqlc.PendingSignup, _a1 error) *MockStore_GetPendingSignupByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetPendingSignupByEmail_Call) RunAndReturn(run func(context.Context, pgtype.Text) (sqlc.PendingSignup, error)) *MockStore_GetPendingSignupByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetPendingSignupByID provides a mock function with given fields: ctx, id
func (_m *MockStore) GetPendingSignupByID(ctx context.Context, id uuid.UUID) (sqlc.PendingSignup, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetPendingSignupByID")
	}

	var r0 sqlc.PendingSignup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (sqlc.PendingSignup, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) sqlc.PendingSignup); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(sqlc.PendingSignup)
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetPendingSignupByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPendingSignupByID'
type MockStore_GetPendingSignupByID_Call struct {
	*mock.Call
}

// GetPendingSignupByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockStore_Expecter) GetPendingSignupByID(ctx interface{}, id interface{}) *MockStore_GetPendingSignupByID_Call {
	return &MockStore_GetPendingSignupByID_Call{Call: _e.mock.On("GetPendingSignupByID", ctx, id)}
}

func (_c *MockStore_GetPendingSignupByID_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockStore_GetPendingSignupByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetPendingSignupByID_Call) Return(_a0 sqlc.PendingSignup, _a1 error) *MockStore_GetPendingSignupByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetPendingSignupByID_Call) RunAndReturn(run func(context.Context, uuid.UUID) (sqlc.PendingSignup, error)) *MockStore_GetPendingSignupByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function with given fields: ctx, email
func (_m *MockStore) GetUserByEmail(ctx context.Context, email pgtype.Text) (sqlc.User, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 sqlc.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Text) (sqlc.User, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, pgtype.Text) sqlc.User); ok {
		r0 = rf(ctx, email)
	} else {
		r0 = ret.Get(0).(sqlc.User)
	}

	if rf, ok := ret.Get(1).(func(context.Context, pgtype.Text) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockStore_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email pgtype.Text
func (_e *MockStore_Expecter) GetUserByEmail(ctx interface{}, email interface{}) *MockStore_GetUserByEmail_Call {
	return &MockStore_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", ctx, email)}
}

func (_c *MockStore_GetUserByEmail_Call) Run(run func(ctx context.Context, email pgtype.Text)) *MockStore_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(pgtype.Text))
	})
	return _c
}

func (_c *MockStore_GetUserByEmail_Call) Return(_a0 sqlc.User, _a1 error) *MockStore_GetUserByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetUserByEmail_Call) RunAndReturn(run func(context.Context, pgtype.Text) (sqlc.User, error)) *MockStore_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementJobRetry provides a mock function with given fields: ctx, arg
func (_m *MockStore) IncrementJobRetry(ctx context.Context, arg sqlc.IncrementJobRetryParams) (sqlc.Job, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for IncrementJobRetry")
	}

	var r0 sqlc.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.IncrementJobRetryParams) (sqlc.Job, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.IncrementJobRetryParams) sqlc.Job); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(sqlc.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, sqlc.IncrementJobRetryParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_IncrementJobRetry_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementJobRetry'
type MockStore_IncrementJobRetry_Call struct {
	*mock.Call
}

// IncrementJobRetry is a helper method to define mock.On call
//   - ctx context.Context
//   - arg sqlc.IncrementJobRetryParams
func (_e *MockStore_Expecter) IncrementJobRetry(ctx interface{}, arg interface{}) *MockStore_IncrementJobRetry_Call {
	return &MockStore_IncrementJobRetry_Call{Call: _e.mock.On("IncrementJobRetry", ctx, arg)}
}

func (_c *MockStore_IncrementJobRetry_Call) Run(run func(ctx context.Context, arg sqlc.IncrementJobRetryParams)) *MockStore_IncrementJobRetry_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(sqlc.IncrementJobRetryParams))
	})
	return _c
}

func (_c *MockStore_IncrementJobRetry_Call) Return(_a0 sqlc.Job, _a1 error) *MockStore_IncrementJobRetry_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_IncrementJobRetry_Call) RunAndReturn(run func(context.Context, sqlc.IncrementJobRetryParams) (sqlc.Job, error)) *MockStore_IncrementJobRetry_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateJobStatus provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateJobStatus(ctx context.Context, arg sqlc.UpdateJobStatusParams) (sqlc.Job, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateJobStatus")
	}

	var r0 sqlc.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.UpdateJobStatusParams) (sqlc.Job, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.UpdateJobStatusParams) sqlc.Job); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(sqlc.Job)
	}

	if rf, ok := ret.Get(1).(func(context.Context, sqlc.UpdateJobStatusParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateJobStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateJobStatus'
type MockStore_UpdateJobStatus_Call struct {
	*mock.Call
}

// UpdateJobStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - arg sqlc.UpdateJobStatusParams
func (_e *MockStore_Expecter) UpdateJobStatus(ctx interface{}, arg interface{}) *MockStore_UpdateJobStatus_Call {
	return &MockStore_UpdateJobStatus_Call{Call: _e.mock.On("UpdateJobStatus", ctx, arg)}
}

func (_c *MockStore_UpdateJobStatus_Call) Run(run func(ctx context.Context, arg sqlc.UpdateJobStatusParams)) *MockStore_UpdateJobStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(sqlc.UpdateJobStatusParams))
	})
	return _c
}

func (_c *MockStore_UpdateJobStatus_Call) Return(_a0 sqlc.Job, _a1 error) *MockStore_UpdateJobStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateJobStatus_Call) RunAndReturn(run func(context.Context, sqlc.UpdateJobStatusParams) (sqlc.Job, error)) *MockStore_UpdateJobStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMagicLink provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdateMagicLink(ctx context.Context, arg sqlc.UpdateMagicLinkParams) (sqlc.MagicLink, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMagicLink")
	}

	var r0 sqlc.MagicLink
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.UpdateMagicLinkParams) (sqlc.MagicLink, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.UpdateMagicLinkParams) sqlc.MagicLink); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(sqlc.MagicLink)
	}

	if rf, ok := ret.Get(1).(func(context.Context, sqlc.UpdateMagicLinkParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateMagicLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMagicLink'
type MockStore_UpdateMagicLink_Call struct {
	*mock.Call
}

// UpdateMagicLink is a helper method to define mock.On call
//   - ctx context.Context
//   - arg sqlc.UpdateMagicLinkParams
func (_e *MockStore_Expecter) UpdateMagicLink(ctx interface{}, arg interface{}) *MockStore_UpdateMagicLink_Call {
	return &MockStore_UpdateMagicLink_Call{Call: _e.mock.On("UpdateMagicLink", ctx, arg)}
}

func (_c *MockStore_UpdateMagicLink_Call) Run(run func(ctx context.Context, arg sqlc.UpdateMagicLinkParams)) *MockStore_UpdateMagicLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(sqlc.UpdateMagicLinkParams))
	})
	return _c
}

func (_c *MockStore_UpdateMagicLink_Call) Return(_a0 sqlc.MagicLink, _a1 error) *MockStore_UpdateMagicLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateMagicLink_Call) RunAndReturn(run func(context.Context, sqlc.UpdateMagicLinkParams) (sqlc.MagicLink, error)) *MockStore_UpdateMagicLink_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePendingSignup provides a mock function with given fields: ctx, arg
func (_m *MockStore) UpdatePendingSignup(ctx context.Context, arg sqlc.UpdatePendingSignupParams) (sqlc.PendingSignup, error) {
	ret := _m.Called(ctx, arg)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePendingSignup")
	}

	var r0 sqlc.PendingSignup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.UpdatePendingSignupParams) (sqlc.PendingSignup, error)); ok {
		return rf(ctx, arg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, sqlc.UpdatePendingSignupParams) sqlc.PendingSignup); ok {
		r0 = rf(ctx, arg)
	} else {
		r0 = ret.Get(0).(sqlc.PendingSignup)
	}

	if rf, ok := ret.Get(1).(func(context.Context, sqlc.UpdatePendingSignupParams) error); ok {
		r1 = rf(ctx, arg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdatePendingSignup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePendingSignup'
type MockStore_UpdatePendingSignup_Call struct {
	*mock.Call
}

// UpdatePendingSignup is a helper method to define mock.On call
//   - ctx context.Context
//   - arg sqlc.UpdatePendingSignupParams
func (_e *MockStore_Expecter) UpdatePendingSignup(ctx interface{}, arg interface{}) *MockStore_UpdatePendingSignup_Call {
	return &MockStore_UpdatePendingSignup_Call{Call: _e.mock.On("UpdatePendingSignup", ctx, arg)}
}

func (_c *MockStore_UpdatePendingSignup_Call) Run(run func(ctx context.Context, arg sqlc.UpdatePendingSignupParams)) *MockStore_UpdatePendingSignup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(sqlc.UpdatePendingSignupParams))
	})
	return _c
}

func (_c *MockStore_UpdatePendingSignup_Call) Return(_a0 sqlc.PendingSignup, _a1 error) *MockStore_UpdatePendingSignup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdatePendingSignup_Call) RunAndReturn(run func(context.Context, sqlc.UpdatePendingSignupParams) (sqlc.PendingSignup, error)) *MockStore_UpdatePendingSignup_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
