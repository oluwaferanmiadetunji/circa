// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: jobs.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (type, payload, max_retries, scheduled_at)
VALUES ($1, $2, $3, $4)
RETURNING id, type, payload, status, retry_count, max_retries, error_message, scheduled_at, processed_at, created_at, updated_at, deleted_at
`

type CreateJobParams struct {
	Type        string    `json:"type"`
	Payload     []byte    `json:"payload"`
	MaxRetries  int32     `json:"max_retries"`
	ScheduledAt time.Time `json:"scheduled_at"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.Type,
		arg.Payload,
		arg.MaxRetries,
		arg.ScheduledAt,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, type, payload, status, retry_count, max_retries, error_message, scheduled_at, processed_at, created_at, updated_at, deleted_at FROM jobs WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetJobByID(ctx context.Context, id uuid.UUID) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getNextPendingJob = `-- name: GetNextPendingJob :one
SELECT id, type, payload, status, retry_count, max_retries, error_message, scheduled_at, processed_at, created_at, updated_at, deleted_at FROM jobs 
WHERE status = 'pending' 
  AND deleted_at IS NULL 
  AND scheduled_at <= NOW()
ORDER BY scheduled_at ASC, created_at ASC
LIMIT 1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) GetNextPendingJob(ctx context.Context) (Job, error) {
	row := q.db.QueryRow(ctx, getNextPendingJob)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const incrementJobRetry = `-- name: IncrementJobRetry :one
UPDATE jobs 
SET retry_count = retry_count + 1,
    status = CASE 
        WHEN retry_count + 1 >= max_retries THEN 'failed'
        ELSE 'pending'
    END,
    error_message = $1,
    scheduled_at = NOW() + INTERVAL '5 minutes' * (retry_count + 1),
    updated_at = NOW()
WHERE id = $2 AND deleted_at IS NULL
RETURNING id, type, payload, status, retry_count, max_retries, error_message, scheduled_at, processed_at, created_at, updated_at, deleted_at
`

type IncrementJobRetryParams struct {
	ErrorMessage *string   `json:"error_message"`
	ID           uuid.UUID `json:"id"`
}

func (q *Queries) IncrementJobRetry(ctx context.Context, arg IncrementJobRetryParams) (Job, error) {
	row := q.db.QueryRow(ctx, incrementJobRetry, arg.ErrorMessage, arg.ID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateJobStatus = `-- name: UpdateJobStatus :one
UPDATE jobs 
SET status = $1, 
    processed_at = CASE WHEN $1 = 'completed' OR $1 = 'failed' THEN NOW() ELSE processed_at END,
    error_message = $2,
    updated_at = NOW()
WHERE id = $3 AND deleted_at IS NULL
RETURNING id, type, payload, status, retry_count, max_retries, error_message, scheduled_at, processed_at, created_at, updated_at, deleted_at
`

type UpdateJobStatusParams struct {
	Status       string    `json:"status"`
	ErrorMessage *string   `json:"error_message"`
	ID           uuid.UUID `json:"id"`
}

func (q *Queries) UpdateJobStatus(ctx context.Context, arg UpdateJobStatusParams) (Job, error) {
	row := q.db.QueryRow(ctx, updateJobStatus, arg.Status, arg.ErrorMessage, arg.ID)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.ErrorMessage,
		&i.ScheduledAt,
		&i.ProcessedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
